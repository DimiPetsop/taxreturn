---
title: "pseudogenes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{pseudogenes}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(taxreturn)
library(Biostrings)
library(tidyverse)
```


#Introduction

This vignette is showing the optimising of the cleanseqs function in order to deal with pseudogenes and other non-homologous loci that can contaminate public sequence data


# Assemble test set

First we get some pseudogene sequences

```{r pseudogenes}
## Fetch sequences from GenBank
test <- fetchSeqs("Insecta", database="genbank", out.dir="vignettes/pseudogenes", quiet=FALSE, marker="COI pseudogene", output = "gb-binom",  subsample=1000, chunk_size=300, compress=TRUE, cores=2)

pseudoCOI <-  readDNAStringSet("vignettes/pseudogenes/Insecta_COI pseudogene_gb.fa.gz")
names(pseudoCOI) <- names(pseudoCOI) %>% str_replace(pattern="(?<=;).*$", replacement = "pseudo")
```

Then we get some off target loci such as COII and COIII that commonly find their way into datasets due to problematic search terms

```{r off-target}
## Fetch COII sequences from GenBank 
fetchSeqs("Insecta", database="genbank", out.dir="vignettes/pseudogenes/pseudogenes", quiet=FALSE, marker="COII", output = "gb-binom", subsample=1000, chunk_size=300, compress=TRUE, cores=1)

## Fetch COIII sequences from GenBank 
fetchSeqs("Insecta", database="genbank", out.dir="vignettes/pseudogenes/pseudogenes", quiet=FALSE, marker="COIII", output = "gb-binom", subsample=1000, chunk_size=300, compress=TRUE, cores=1)

COII <-  readDNAStringSet("vignettes/pseudogenes/Insecta_COII_gb.fa.gz")
names(COII) <- names(COII) %>% str_replace(pattern="(?<=;).*$", replacement = "COII")

COIII <-  readDNAStringSet("vignettes/pseudogenes/Insecta_COIII_gb.fa.gz")
names(COIII) <- names(COIII) %>% str_replace(pattern="(?<=;).*$", replacement = "COIII")

off_target <- c(COII, COIII)
```

And finally, get some real COI sequences
```{r off-target}
## Fetch subsample of 1000 COI sequences from GenBank 
fetchSeqs("Insecta", database="genbank", out.dir="vignettes/pseudogenes/pseudogenes", quiet=FALSE, marker="COI OR COI OR COX1 OR COXI", output = "gb-binom", subsample=1000, chunk_size=300, compress=TRUE, cores=1)

realCOI <-  readDNAStringSet("vignettes/pseudogenes/Insecta_COI OR COI OR COX1 OR COXI_gb.fa.gz")
names(realCOI) <- names(realCOI) %>% str_replace(pattern="(?<=;).*$", replacement = "COI")
```

We then merge these together, we will flag in their name if they are real sequences, off target sequences, or pseudogenes

```{r merge seqs}
mergedSeqs <- c(realCOI, pseudoCOI, off_target)
writeXStringSet(mergedSeqs, filepath="vignettes/pseudogenes/mergedseqs.fa")
```

```{r basc}
args = commandArgs(TRUE)
input1 = args[1]

#load packages
library(Biostrings)
library(tidyverse)
library(taxreturn)

mergedSeqs <- readDNAStringSet(filepath=input1)

#Test different minscores for cleaning sequences
minscores <- seq(0,2000,50)

summary <- vector("list", length=length(minscores))

for (i in 1:length(minscores)) {
filtered <- clean_seqs(mergedSeqs, model, minscore = minscores[i], cores=18, shave=TRUE)
summary[[i]] <- names(filtered) %>% str_replace(pattern="^[^;]+;", replacement="") %>% table() %>% as.data.frame()  %>% mutate(minscore = minscores[i])
print(summary[[i]])
closeAllConnections()
}

out <- bind_rows(summary)
write.tsv(out, "minscore_pseudo.tsv")

```

## Test translation
```{r gap pseudogene filter}
load("C:/Users/ap0y/Dropbox/R/taxreturn/data/model.rda")

test <- sample(realCOI, 50)
filtered <- clean_seqs(test, model, minscore = 500, cores=2, shave=TRUE)

# Need to add ambiguity filter to codon_filer
filt2 <- codon_filter(test, remove.ambiguities = TRUE)

```



## Testing with increase
