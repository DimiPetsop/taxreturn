
# Alignment utilities -----------------------------------------------------

#' Get primer binding position
#'
#' @param primer A character string, DNAbin object or an object coercible to DNAbin
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param tryrc Whether the reverse complement should also be aligned. The highest scoring complement is chosen.
#' @param quiet Whether progress should be printed to the console.
#' @param minscore Minimum score for the viterbi alignment.
#' @param ... aditional arguments to be passed to "Viterbi"
#'
#' @return
#' @export
#' @import aphid
#' @import insect
#' @import stringr
#' @import ape
#'
#' @examples
get_binding_position <- function (primer, model, tryrc = TRUE, quiet = FALSE, minscore = 10, ...) {

  input <- primer
  if (!inherits(model, "PHMM")) { stop("Error: model must be a PHMM object")}

  if (!is.null(primer)) {
    if (!inherits(primer, "DNAbin")) {
      if (mode(primer) == "character") {
        if (nchar(primer[1]) == 1) {primer <- paste0(primer, collapse = "")}
        if(stringr::str_detect(primer, "I")) {message(paste0("Warning: Inosine (I) bases detected in primer ", input," these will be converted to N!"))}
        primer <- insect::char2dna(primer)
      }
      else {
        if (!inherits(primer, "PHMM"))
          stop("Invalid primer(s)\n")
      }
    }
  }

  up <- primer[!primer %in% as.raw(c(2, 4))]
  vitF <- aphid::Viterbi(model, up, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")

  if (tryrc == TRUE) {
    down <- ape::complement(primer)
    down <- down[!down %in% as.raw(c(2, 4))]
    vitR <- aphid::Viterbi(model, down, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")
    if (vitF$score > vitR$score && vitF$score > minscore) {
      if (!quiet) {
        message("Forward complement matched alignment")
      }
      path <- vitF$path
      score <- vitF$score
    } else if (vitF$score < vitR$score && vitR$score > minscore) {
      if (!quiet) {
        message("Reverse complement matched alignment")
      }
      path <- vitR$path
      score <- vitR$score
    } else if (vitF$score && vitR$score < minscore) {
      score <- max(vitF$score, vitR$score)
      out <- data.frame(primer = input, start = NA, end = NA, score=score)
      return(out)
      stop("Error: Both complements of primer were below minscore")
    }
  } else if(tryrc == FALSE && vitF$score > minscore) {
    path <- vitF$path
    score <- vitF$score
  } else {
    score <- max(vitF$score, vitR$score)
    out <- data.frame(primer = input, start = NA, end = NA, score=score)
    return(out)
    Stop("Error: Forward complement of primer was below minscore")
  }

  matchF <- match(1, path)
  matchR <- (length(path) - (match(1, rev(path)) - 1))
  if ((matchR - (matchF - 1)) == length(primer[[1]])) {
    out <- data.frame(primer = input, start = matchF, end = matchR, score=score)
  }  else if ((matchR - (matchF - 1)) > length(primer[[1]])) {
    message("Warning: binding positions are larger than the primer length")
  }  else if ((matchR - (matchF - 1)) < length(primer[[1]])) {
    message("Warning: binding positions are less than the primer length")
  }
  return(out)
}

#' Get subalignment
#'
#' @description Aligns a DNABin to a reference PHMM model, and returns the optimal path
#' @param x A DNAbin object or an object coercible to DNAbin
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param tryrc Whether the reverse complement should also be aligned
#' @param quiet Whether progress should be printed to the console.
#' @param check_indels Check that indels are multiples of 3, recommended for coding sequences such as COI
#' @param minscore Minimum score for the viterbi alignment
#' @param omit.endgaps Should gap characters at each end of the sequences be ignored when deriving the transition probabilities of the model? Defaults to FALSE. Set to TRUE if x is not a strict global alignment (i.e. if the alignment contains partial sequences with missing sections represented with gap characters).
#' @param cores Integer giving the number of CPUs to parallelize the operation over. Defaults to 1, and reverts to 1 if x is not a list. This argument may alternatively be a 'cluster' object, in which case it is the user's responsibility to close the socket connection at the conclusion of the operation, for example by running parallel::stopCluster(cores). The string 'autodetect' is also accepted, in which case the maximum number of cores to use is one less than the total number of cores available. Note that in this case there may be a tradeoff in terms of speed depending on the number and size of sequences to be aligned, due to the extra time required to initialize the cluster.
#' @param ... aditional arguments to be passed to "Viterbi"
#'
#' @return
#' @export
#' @import aphid
#' @import insect
#' @import ape
#'
#'
#' @examples
get_subalignment <- function(x, model, tryrc=FALSE, quiet=FALSE, check_indels=TRUE, minscore=10, omit.endgaps	= FALSE, cores=1, ...) {

  # Ensure x is a DNAbin
  if (!inherits(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {
      stop("Error: Object is not coercible to DNAbin \n")
    }
  }
  up <- aphid::derivePHMM(x, cores=cores, omit.endgaps = omit.endgaps, ...=...)
  vitF <- aphid::Viterbi(model, up, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")

  # Derive PHMM
  if(tryrc == TRUE) {
    if(!quiet){message("Deriving PHMM for reverse complement")}
    down <- aphid::derivePHMM(ape::complement(x), cores=cores, omit.endgaps = omit.endgaps, ...=...)
    vitR <- aphid::Viterbi(model, down, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")

    if (vitF$score > vitR$score && vitF$score > minscore) {
      if(!quiet){message("Forward complement matched alignment")}
      path <- vitF$path

    } else if (vitF$score < vitR$score && vitR$score > minscore) {
      if(!quiet){message("Reverse complement matched alignment")}
      path <- vitR$path

    } else if( vitF$score && vitR$score < minscore ){
      return(NULL)
      stop("Both complements of primer were below minscore")

    }
  } else if(tryrc == FALSE && vitF$score > minscore) {
    path <- vitF$path
  } else {Stop("Forward complement of primer was below minscore")}
  return(path)
}


#' Pad alignment
#'
#' @description Aligns a DNABin to a reference PHMM model, and pads any gaps between the query and reference
#' @param x A DNAbin object or an object coercible to DNAbin
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param pad The character used to pad the gaps
#' @param tryrc Whether the reverse complement should also be aligned
#' @param quiet Whether progress should be printed to the console.
#' @param check_indels Check that indels are multiples of 3, recommended for coding sequences such as COI
#' @param minscore Minimum score for the viterbi alignment
#' @param omit.endgaps Should gap characters at each end of the sequences be ignored when deriving the transition probabilities of the model? Defaults to FALSE. Set to TRUE if x is not a strict global alignment (i.e. if the alignment contains partial sequences with missing sections represented with gap characters).
#' @param cores Integer giving the number of CPUs to parallelize the operation over. Defaults to 1, and reverts to 1 if x is not a list. This argument may alternatively be a 'cluster' object, in which case it is the user's responsibility to close the socket connection at the conclusion of the operation, for example by running parallel::stopCluster(cores). The string 'autodetect' is also accepted, in which case the maximum number of cores to use is one less than the total number of cores available. Note that in this case there may be a tradeoff in terms of speed depending on the number and size of sequences to be aligned, due to the extra time required to initialize the cluster.
#' @param ... aditional arguments to be passed to "Viterbi"
#'
#' @return
#' @export
#' @import aphid
#' @import insect
#' @import ape
#' @import stringr
#'
#' @examples
pad_alignment <- function(x, model, pad = "-", tryrc = FALSE, check_indels = TRUE, minscore = 10, omit.endgaps	= FALSE, cores = 1,  quiet = FALSE, ...){

  path <- get_subalignment(x = x, model = model, tryrc = tryrc, check_indels = check_indels, minscore = minscore, omit.endgaps=omit.endgaps,cores = cores, quiet = quiet, ...=...)

  # Find start, stop, and indels
  matchF <- match(2, path)
  matchR <- (length(path) - (match(2, rev(path))-1))
  indels <- which(path == 0, arr.ind=FALSE)
  # potentially could have indels as 1's as well, due to potential for indels to be recorded in PhMM?
  # Do another check for which(path ==1, arr.ind=FALSE), and make sure they are more than matchF and less than matchR to be recorded as indels

  # Pad Left
  if (matchF > 1){
    left_pad <- which(path == 1, arr.ind=FALSE)
    left_pad <- left_pad[which(left_pad < matchF)]
  } else(left_pad <- NULL)

  # Detect indels
  if (length(indels) > 1) {
    # Detect multiple indels
    splitAt <- function(x, pos) unname(split(x, cumsum(seq_along(x) %in% pos)))
    split <- splitAt(indels, which(diff(indels) > 1, arr.ind=FALSE)+1)

    # Confirm all indels are 1 codon deletions
    if (check_indels == TRUE && !all(sapply(split, length) %in% seq(3,12,3))) {
      stop("ERROR: Indels are not in multiples of 3!")
    }
  } else (indels <- NULL)

  # Pad right
  if (matchR < length(path)){
    right_pad <- which(path == 1, arr.ind = FALSE)
    right_pad <- right_pad[which(right_pad > matchR)]
  } else (right_pad <- NULL)

  insert <- c(left_pad, indels+length(left_pad), right_pad+length(left_pad)+length(indels))

  x <- as.character(x)
  insert_at <- function(x, index) {
    x <-  paste0(x, collapse = "")
    for(i in 1:length(index)) {
      stringr::str_sub(x, start = index[i], end = index[i]-1) <- pad
    }
    x <- stringr::str_to_upper(x)
    return(x)
  }
  out <- sapply(x, insert_at, insert)
  out <- insect::char2dna(out)
  return(out)
}


# Alignment entropy -------------------------------------------------------

#' Alignment entropy
#'
#' @param x A DNAbin or AAbin object
#' @param maskgaps The threshold of gaps allowed before a position in the alignment is masked
#' @param countgaps Whether gaps should be counted within entropy calculations. Default is FALSE.
#' @param method 	the method employed by `entropy::entropy` to estimate alignment entropy. Accepts:
#' "ML" : maximum likelihood
#' "MM" : bias-corrected maximum likelihood,
#' "Jeffreys" : Dirichlet with a=1/2
#' "Laplace" : Dirichlet with a=1
#' "SG" : Dirichlet with a=a=1/length(y)
#' "minimax" : Dirichlet with a=sqrt(sum(y))/length(y)
#' "CS" : ChaoShen
#' "NSB": Nemenman, Shafee and Biale (2002)
#' "shrink" : Shrinkage estimator
#' See the help page of `entropy::entropy` for more information
#' @param unit the unit in which entropy is measured. The default is "nats" (natural units). For computing entropy in "bits" set unit="log2".
#' @param return_extra Whether to return a dataframe including extra columns including individual base counts, gap proportions and number of bases at each position
#'
#' @return
#' @export
#' @import entropy
#' @import ape
#' @import purrr
#'
#'
#' @examples
alignment_entropy <- function (x, maskgaps=0.2, countgaps = FALSE, method="ML", unit="log", return_extra=FALSE) {
  if ((maskgaps < 0) | (maskgaps > 1)) {
    stop("maskgaps should be a percentage (within the [0,1] range).")
  }

  if(class(x)=="DNAbin"){
    x <- as.character(x)
    x <- lapply(x, toupper)
    names <- c("A", "C", "G", "T", "-")
  } else if(class(x)=="AAbin"){
    x <- as.character(x)
    x <- lapply(x, toupper)
    names <- c("A", "C", "D", "E", "F",
               "G", "H", "I", "K", "L",
               "M", "N", "P", "Q", "R",
               "S", "T", "V", "W", "Y", "-")
  }

  if(isTRUE(countgaps)){
    counter <- names
  } else if(isFALSE(countgaps)){
    counter <- names[!names=="-"]
  }

  #Create matrix
  suppressWarnings(MSA <- matrix(as.vector(unlist(x)), ncol = length(x[[1]]), byrow = TRUE))

  n_seq <- length(MSA[,1])
  n_pos <- length(MSA[1,])

  #Summarise each position in alignment
  i=1
  df <- data.frame(matrix(ncol = length(names), nrow = n_pos))
  colnames(df) <- names

  for(i in 1:n_pos){
    df[i,names] <- sapply(names, function(x){ sum(MSA[, i] == x)})
  }
  ent <- df %>%
    dplyr::mutate(pos = rownames(.),
                  bases = n_seq - `-`,
                  prop_gaps = `-` / n_seq,
                  together = pmap(unname(.[counter]), c)) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(ent = entropy::entropy(together, method=method, unit=unit)) %>%
    dplyr::mutate(ent = dplyr::case_when(
      prop_gaps > maskgaps ~ as.numeric(NA),
      prop_gaps <= maskgaps ~ ent
    )) %>%
    dplyr::select(-together)

  if(isTRUE(return_extra)){
    out <- ent
  } else if(isFALSE(return_extra)){
    out <- ent$ent
    names(out) <- ent$pos
  }
  message("Masked ", sum(is.na(ent)), " alignment positions with over ", (maskgaps*100), "% gaps")
  return(out)
}


# Summarise fasta ---------------------------------------------------------


#' summarise_fasta
#'
#' @param x The location of a fasta file or gzipped fasta file.
#' @param label optional, Add an extra column with a label
#' @param origin optional, a table with sequence id numbers and their database origins
#'
#' @return
#' @export
#' @import Biostrings
#' @import stringr
#' @import dplyr
#'
#'
#' @examples
summarise_fasta <- function(x, label=NULL, origin=NULL) {
  if(is.null(origin)){
    out <- Biostrings::fasta.index(x) %>%
      dplyr::mutate(taxid = desc %>%
                      stringr::str_remove(pattern="(;)(.*?)(?=$)")  %>%
                      stringr::str_remove(pattern="(^)(.*?)(?<=\\|)")) %>%
      dplyr::summarise(nseqs = n(),
                       nspecies=n_distinct(taxid),
                       mean_length = mean(seqlength),
                       q0 = quantile(seqlength, probs=0),
                       q25 = quantile(seqlength, probs=0.25),
                       q50 = quantile(seqlength, probs=0.5), # Q50 is median
                       q75 = quantile(seqlength, probs=0.75),
                       q100 = quantile(seqlength, probs=1)
      )

  } else if(is.data.frame(origin) | is_tibble(origin)){

    if(any(duplicated(origin$seqid))){
      stop("Origin table has duplicated seqids")
    }
    out <- Biostrings::fasta.index(x) %>%
      dplyr::mutate(taxid = desc %>%
                      stringr::str_remove(pattern="(;)(.*?)(?=$)")  %>%
                      stringr::str_remove(pattern="(^)(.*?)(?<=\\|)")) %>%
      dplyr::mutate(seqid = desc %>%
                      stringr::str_remove(pattern="(\\|)(.*?)(?=$)"))  %>%
      dplyr::left_join(origin, by="seqid") %>%
      dplyr::group_by(taxid) %>%
      dplyr::mutate(origin = paste(sort(unique(origin)), collapse="/"))%>% #Combine origins to make sure they arent duplicated
      dplyr::ungroup() %>%
      dplyr::group_by(origin) %>%
      dplyr::summarise(nseqs = n(),
                       nspecies=n_distinct(taxid),
                       mean_length = mean(seqlength),
                       q0 = quantile(seqlength, probs=0),
                       q25 = quantile(seqlength, probs=0.25),
                       q50 = quantile(seqlength, probs=0.5), # Q50 is median
                       q75 = quantile(seqlength, probs=0.75),
                       q100 = quantile(seqlength, probs=1)
      )
  }
  if(is.character(label)) {
    out <- out %>%
      dplyr::mutate(label  = label)
  }
  return(out)
}
