
#' Clean Sequences with PHMM
#'
#' @param x A DNAbin or DNAStringset object
#' @param model A profile hidden Markov model (a "PHMM" object) generated by the aphid R package to align the sequences to.
#' @param minscore The minimum specificity (log-odds score for the optimal alignment) between the query sequence and the PHMM model for the sequence to be retained in the output object.
#' @param shave Whether bases that are outside (to the left or right) of the PHMM object should be shaved from the outputs.
#' @param maxNs The max number of ambiguous N bases to retain
#' @param cores The number of CPUs to parallelize the operation over
#' @param quiet Whether progress should be printed to the console.
#'
#'
#' @import aphid
#' @import insect
#' @import Biostrings
#' @import ape
#' @import stringr
#' @import parallel
#' @import pbapply
#'
#' @return
#' @export
#'
#' @examples
clean_seqs <- function(x, model, minscore = 100, shave = TRUE, maxNs = 0, cores = 1,
                       quiet = FALSE, progress = FALSE, ...) {
  .Deprecated("map_to_model", package="taxreturn",  old = as.character(sys.call(sys.parent()))[1L])
  time <- Sys.time() # get time

  # Convert to DNAbin
  if (!is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if (!is(model, "PHMM")) {
    stop("Model needs to be a PHMM object")
  }
  # Define PHMM function

  filt_phmm <- function(s, model, minscore, minamplen, maxamplen, ...) {

    s <- s[!s %in% as.raw(c(2, 4))]
    vit <- aphid::Viterbi(model, s, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")

    if (vit$score < minscore) {
      return(NULL)
    }
    path <- vit$path
    match1 <- match(1, path)
    match2 <- match(1, rev(path))

    if (is.na(match1) | is.na(match2)) {
      return(NULL)
    }

    if (shave == TRUE) {
      ntoshavef <- match(c(0, 1), rev(vit$path)) - 1
      ntoshavef <- min(ntoshavef[!is.na(ntoshavef)])
      last <- length(s) - ntoshavef
      begin <- match(c(0, 1), vit$path)
      begin <- min(begin[!is.na(begin)])
      s <- s[begin:last]
    }
    attr(s, "score") <- vit$score
    return(s)
  }

  nseq <- length(x)

  if (cores == 1 && progress == TRUE) {
    requireNamespace("pbapply", quietly = TRUE)
    x <- pbapply::pblapply(x, filt_phmm, model, minscore)
  } else if (cores == 1 && progress == FALSE) {
    x <- lapply(x, filt_phmm, model, minscore)
  } else if (cores > 1 && progress == TRUE) {
    stop("Progress bar currently not supported for multithreading")
  } else {
    navailcores <- parallel::detectCores()
    if (identical(cores, "autodetect")) cores <- navailcores - 1
    if (!(mode(cores) %in% c("numeric", "integer"))) stop("Invalid 'cores'")
    if (cores > navailcores) stop("Number of cores is more than available")

    if (cores > 1) {
      if (!quiet) cat("Multithreading with", cores, "cores\n")

      cores <- parallel::makeCluster(cores, outfile = "out.txt")
      # parallel::clusterExport(cores, c("model", "minscore"))
      junk <- parallel::clusterEvalQ(cores, sapply(c("aphid", "insect", "ape"), require, character.only = TRUE)) # Discard result

      x <- parallel::parLapply(cores, x, filt_phmm, model, minscore)
      parallel::stopCluster(cores)
    } else {
      x <- lapply(x, filt_phmm, model, minscore)
    }
  }

  discards <- sapply(x, is.null)
  nseq <- sum(!discards)

  if (nseq > 0) {
    if (!quiet) cat("Retained", nseq, "sequences after alignment to PHMM\n")
    scores <- unlist(lapply(x, function(s) attr(s, "score")), use.names = FALSE)
    x <- x[!discards]
    x <- ape::as.DNAbin(ape::as.character.DNAbin(x))
  } else {
    if (!quiet) cat("None of the sequences met PHMM specificity criteria. Returning NULL\n")
    x <- NULL
  }
  if (!quiet) cat("Filtering ambiguous sequences\n")
  discards <- sapply(x, function(s) sum(s == 0xf0) / length(s)) > maxNs
  x <- insect::subset.DNAbin(x, subset = !discards)
  if (!quiet) cat(length(x), "sequences retained after applying ambiguity filter\n")
  if (!quiet) cat("Bases overhanging PHMM shaved from alignment\n")
  if (!quiet) cat("Done\n")
  time <- Sys.time() - time
  if (!quiet) (message(paste0("finished in ", format(time, digits = 2))))
  return(x)
}



# map to model ------------------------------------------------------------

## TO REPLACE CLEANSEQS

#' Map sequences to PHMM
#'
#' @param x A DNAbin or DNAStringset object
#' @param model A profile hidden Markov model (a "PHMM" object) generated by `aphid::derivePHMM` to align the sequences to.
#' @param minscore The minimum specificity (log-odds score for the optimal alignment) between the query sequence and the PHMM model for the sequence to be retained in the output object.
#' @param shave Whether bases that are outside (to the left or right) of the PHMM object should be shaved from sequences in the output.
#' @param check_indels Whether sequences with indels not in multiples of 3 should be removed from output. Useful for coding regions such as COI.
#' @param maxNs The max number of ambiguous N bases to retain
#' @param multithread Whether multithreading should be used, if TRUE the number of cores will be automatically detected, or provided a numeric vector to manually set the number of cores to use
#' @param quiet Whether progress should be printed to the console.
#' @param ... Any further arguments to be passed to `aphid::Viterbi`
#'
#'
#' @import aphid
#' @import insect
#' @import Biostrings
#' @import stringr
#' @import parallel
#' @import pbapply
#'
#' @return
#' @export
#'
#' @examples
map_to_model <- function(x, model, minscore = 100, shave = TRUE, check_indels = TRUE, maxNs = Inf,
                         multithread = FALSE, quiet = FALSE, progress = FALSE, ...) {
  time <- Sys.time() # get time

  # Convert to DNAbin
  if (!is(x, "DNAbin")) {
    x <- ape::as.DNAbin(x)
    if (all(is.na(ape::base.freq(x)))) {stop("Error: Object is not coercible to DNAbin \n")}
  }
  if (!is(model, "PHMM")) {
    stop("Model needs to be a PHMM object")
  }
  # Define PHMM function
  filt_phmm <- function(s, model, minscore = 100, shave = TRUE, check_indels=TRUE, ...) {
    s <- s[!s %in% as.raw(c(2, 4))] #Remove gaps
    vit <- aphid::Viterbi(model, s, odds = TRUE, type = "semiglobal", cpp = TRUE, residues = "DNA")

    if (vit$score < minscore) {
      return(NULL)
    }
    path <- vit$path

    #Get starting position of F direction
    matchF <- match(1, path)
    #check its not a bad alignment
    matchcheckF <- path[seq(matchF, matchF+10)] == 1
    if(!all(matchcheckF)){
      newstart <- (matchF + match(FALSE, matchcheckF) - 1)
      matchF <- (match(1, path[newstart:length(path)])+newstart-1)
    }

    #Get starting position of R direction
    matchR <- match(1, rev(path))
    matchcheckR <- rev(path)[seq(matchR, matchR+10)] == 1
    if(!all(matchcheckR)){
      newstart <- (matchR + match(FALSE, matchcheckR) - 1)
      matchR <- (match(1, rev(path)[newstart:length(rev(path))])+newstart-1)
    }
    if (is.na(matchF) | is.na(matchR)) {
      return(NULL)
    }

    #Confirm all deletions are 1 codon deletions
    if (check_indels == TRUE) {
    # get indels (0 is a deletion state, 2 is an insertion)
    insertions <- which(path[matchF:(length(path) - matchR)] == 2, arr.ind=FALSE)
    insertions <- (insertions+matchF) - 1
    deletions <- which(path[matchF:(length(path) - matchR)] == 0, arr.ind=FALSE)
    deletions <- (deletions+matchF) - 1
    if (length(deletions) > 0 | length(insertions) > 0) {
      # Count sequential indels
      splitAt <- function(x, pos) unname(split(x, cumsum(seq_along(x) %in% pos)))
      insplit <- splitAt(insertions, which(diff(insertions) > 1, arr.ind=FALSE)+1)
      delsplit <- splitAt(deletions, which(diff(deletions) > 1, arr.ind=FALSE)+1)
        if(!all(sapply(insplit, length) %in% seq(3,12,3))){
            return(NULL)
        }
        if(!all(sapply(delsplit, length) %in% seq(3,12,3))){
          return(NULL)
        }
      }
    }

    # if shave is true, shave to alignment 2 = insert state so can maybe detect this as well
    if (isTRUE(shave) & any(path==2)) {
      last <- match(c(0, 1), rev(path)) - 1
      last <- min(last[!is.na(last)])  # Getting the min, ignores deletions in the middle
      begin <- match(c(0, 1), path)
      begin <- min(begin[!is.na(begin)])
      s <- s[begin: (length(s) - last)]
      path <- path[begin:(length(path)-last)]
    }

    # Insert gaps to pad sequence out to the alignment length
    out <- as.raw(path)
    out[out==01] <- s
    out[out==00] <- as.raw(04)
    attr(out, "score") <- vit$score
    return(out)
  }

  # setup multithreading
  ncores <- future::availableCores() -1
  if(isTRUE(multithread)){
    cores <- ncores
    if(!quiet){message("Multithreading with ", cores, " cores")}
    future::plan(future::multiprocess, workers=cores)
  } else if (is.numeric(multithread) & multithread > 1){
    cores <- multithread
    if(cores > ncores){
      cores <- ncores
      message("Warning: the value provided to multithread is higher than the number of cores, using ", cores, " cores instead")
    }
    if(!quiet){message("Multithreading with ", cores, " cores")}
    future::plan(future::multiprocess, workers=cores)
  } else if(isFALSE(multithread) | multithread==1){
    future::plan(future::sequential)
  } else (
    stop("Multithread must be a logical or numeric vector of the numbers of cores to use")
  )


  #Apply filt_phmm to all sequences
  res <-  furrr::future_map(x, filt_phmm, model=model, minscore=minscore, shave=shave, check_indels=check_indels,
                            .progress = progress) #, ...=...

  #Close all worker threads
  future::plan(future::sequential)

  discards <- sapply(res, is.null)
  nseq <- sum(!discards)

  if (nseq > 0) {
    if (!quiet) message("Retained ", nseq, " sequences after alignment to PHMM \n")
    scores <- unlist(lapply(res, function(s) attr(s, "score")), use.names = FALSE)
    res <- res[!discards]
    res <- ape::as.DNAbin(ape::as.character.DNAbin(res))
  } else {
    if (!quiet) message("None of the sequences met PHMM specificity criteria. Returning NULL \n")
    res <- NULL
  }
  if(maxNs < Inf){
    discards <- sapply(res, function(s) sum(s == 0xf0) / length(s)) > maxNs
    res <- insect::subset.DNAbin(res, subset = !discards)
    if (!quiet) message(length(res), " sequences retained after applying ambiguity filter \n")
  }
  time <- Sys.time() - time
  if (!quiet) (message(paste0("finished in ", format(time, digits = 2))))
  return(res)
}


# Prune group sizes -------------------------------------------------------

#' Prune group sizes
#'
#' @param x A DNAbin or DNAStringset object
#' @param maxGroupSize The maximum number of sequences with the same taxonomic annotation to keep
#' @param dedup Whether completetely identical sequences should be discarded first
#' @param quiet Whether progress should be printed to the console.
#' @param discardby How sequences from groups with size above maxGroupSize should be discarded.
#' Options include "length" (Default) which will discard sequences from smallest to largest until the group is below maxGroupSize,
#' "random" which will randomly pick sequences to discard until the group is below maxGroupSize,
#' and "novelty" which will conduct a local alignment, and discard the least unique sequences first until all sequences are unique,
#' then discard sequences by length until the group is below maxGroupSize (Note: "novelty" is not yet implemented)
#'
#' @return
#' @export
#'
#' @import insect
#' @import magrittr
#' @import dplyr
#' @import stringr
#' @import tibble
#' @import tidyr
#'
#'
#' @examples
prune_groups <- function(x, maxGroupSize = 5, dedup = TRUE, discardby = "length", quiet = FALSE) {
  if (dedup) {
    dup <- length(x)
    x <- insect::subset.DNAbin(x, subset = !insect::duplicated.DNAbin(x, point = TRUE))
    if (!quiet) cat(paste0((dup - length(x)), " duplicate sequences removed \n"))
  }

  groups <- names(x) %>%
    stringr::str_split_fixed(";", n = 2) %>%
    tibble::as_tibble(.name_repair = ~ c("acc", "taxon")) %>%
    tidyr::separate(acc, into = c("acc", "taxid"), sep="\\|") %>%
    dplyr::pull(taxid)
  groupCounts <- table(groups) # Count number of seqs per group
  u_groups <- names(groupCounts) # Get unique groups

  remove <- logical(length(x))
  if (discardby == "random") {
    for (i in which(groupCounts > maxGroupSize)) {
      index <- which(groups == u_groups[i])
      keep <- sample( # Take random sample
        length(index),
        maxGroupSize
      )
      remove[index[-keep]] <- TRUE
    }
  } else if (discardby == "length") {
    y <- dna2char(x)
    for (i in which(groupCounts > maxGroupSize)) {
      index <- which(groups == u_groups[i])
      rem <- stringr::str_count(y[index], "A|C|T|G")
      names(rem) <- index
      rem <- sort(rem, decreasing = TRUE)
      keep <- as.integer(names(rem[1:maxGroupSize]))
      remove[index[!index %in% keep]] <- TRUE
    }
  }
  x <- x[!remove]
  if (!quiet) cat(paste0(sum(remove), " sequences pruned from over-represented groups"))
  return(x)
}


# Get Reading frame ---------------------------------------------------------------

#' Get Reading frame of sequences
#'
#' @param x Sequences in DNAStringset or DNAbin format
#' @param genetic.code A genetic code for the Amino acid translation. See all known codes at GENETIC_CODE_TABLE
#' Default is the invertebrate mitochondrial code 'SGC4'
#' @param forward whether the forward complement should be returned
#' @param reverse Whether the reverse complemement should be returned
#' @param resolve_draws How draws should be resolved when multiple possible frames produce sequences with no stop codons.
#'
#' @return
#' @export
#'
#' @import ape
#' @import Biostrings
#'
#' @examples
get_reading_frame <- function(x, genetic.code = "SGC4", forward=TRUE, reverse=FALSE, resolve_draws="majority") {
  # Convert to DNAStringSet
  if (is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
  }
  #Check for N's
  if(hasOnlyBaseLetters(x) == FALSE) {stop("Error: Sequences contain ambiguities")}
  #discards <- sapply(x, hasOnlyBaseLetters)
  #x <- insect::subset.DNAbin(x, subset = !discards)

  if(forward==TRUE) {
    F_frames <- lapply(1:3, function(pos) subseq(x, start=pos))
  }
  if(reverse==TRUE) {
    R_frames <- lapply(1:3, function(pos) subseq(reverseComplement(x), start=pos))
  }
  #Translate all reading frames
  suppressWarnings(translated <- lapply(F_frames, translate, genetic.code = getGeneticCode(genetic.code)))
  #select the reading frames that contain 0 stop codons, or return NA
  reading_frame <- vector("integer", length=length(x))
  for (i in 1:length(x)){
    fvec = c(str_count(as.character(translated[[1]][i]), "\\*"),
             str_count(as.character(translated[[2]][i]), "\\*"),
             str_count(as.character(translated[[3]][i]), "\\*"))
    if(sum(fvec==0)==1){
      reading_frame[i] <- which(fvec==0)
    } else if(sum(fvec==0)>1) {
      reading_frame[i] <- 0
    }else if(sum(fvec==0)==0) {
      reading_frame[i] <- NA
    }
  }
  if (resolve_draws == "majority") {
    reading_frame[reading_frame==0] <- reading_frame[which.max(tabulate(reading_frame))]
  } else if (resolve_draws == "remove") {
    reading_frame[reading_frame==0] <- NA
  }
  return(reading_frame)
}


# Codon_filter ------------------------------------------------------------

#' Filter sequences containing stop codons
#'
#' @param x Sequences in DNAStringset or DNAbin format
#' @param genetic.code A genetic code for the Amino acid translation. See all known codes at GENETIC_CODE_TABLE
#' Default is the invertebrate mitochondrial code 'SGC4'
#' @param forward Whether the forward complement should be used
#' @param reverse Whether the reverse complement should be used
#' @param remove.ambiguities Whether ambiguous bases (non ATGC) bases should be removed
#'
#' @return
#' @export
#' @import ape
#' @import Biostrings
#' @import DECIPHER
#'
#' @examples
codon_filter <- function(x, genetic.code = "SGC4", forward=TRUE, reverse=FALSE, remove.ambiguities=TRUE){
  # Convert to DNAStringSet
  if (is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
    format <- "DNAbin"
  } else if(is(x, "DNAStringSet")){
    format <- "DNAStringSet"
  } else {
    stop("x must be a DNAbin or DNAStringSet")
  }

  #Check for Ambiguities
  nogaps <- DECIPHER::RemoveGaps(x)
  if(Biostrings::hasOnlyBaseLetters(nogaps) == FALSE & remove.ambiguities == FALSE) {
    stop("Error: Sequences containing ambiguities, set remove.ambiguities to TRUE")
  } else if(Biostrings::hasOnlyBaseLetters(nogaps) == FALSE & remove.ambiguities==TRUE) {
    discards <- sapply(nogaps, Biostrings::hasOnlyBaseLetters)
    discards <- discards[discards == FALSE]
    x <- x[which(!names(nogaps) %in% names(discards))]
    message(paste0(length(discards), " Sequences containing ambiguities were removed"))
  }

  #Get reading frames
  frames <- get_reading_frame(x, genetic.code = genetic.code, forward = forward, reverse = reverse)
  x <- x[!is.na(frames)]

  if(format=="DNAbin"){
    out <- ape::as.DNAbin(x)
  } else if(format=="DNAStringSet"){
    out <- x
  }
  message(paste0(length(x) - length(out), " Sequences containing stop codons removed"))
  return(out)
}

# Codon entropy  -----------------------------------------------------------

#' Codon entropy
#'
#' @param x
#' @param genetic.code
#' @param forward
#' @param reverse
#' @param codon.filter
#'
#' @return
#' @export
#' @import ape
#' @import Biostrings
#' @import entropy
#' @import purrr
#'
#'
#' @examples
codon_entropy <- function(x, genetic.code = "SGC4", forward=TRUE, reverse=FALSE, codon.filter = TRUE, method="ML") {
  if (is(x, "DNAbin")) {
    x <- DNAbin2DNAstringset(x, remove_gaps=FALSE)
  }
  #Filter out sequences with stop codons
  if(codon.filter == TRUE){
  x <- codon_filter(x, genetic.code = genetic.code, forward = forward, reverse = reverse)
  }

  #subset to the reading frame
  pos <- get_reading_frame(x, genetic.code = genetic.code, forward = forward, reverse = reverse)

  F_frames <-  as.character(subseq(x, start= pos))

  ent <- vector("list", length=length(F_frames))
  for (l in 1:length(F_frames)){
    ent[[l]] <- c(
      entropy::entropy(table(purrr::map_chr(seq(1, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method),
      entropy::entropy(table(purrr::map_chr(seq(2, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method),
      entropy::entropy(table(purrr::map_chr(seq(3, nchar(F_frames[l]), 3), function(i) substr(F_frames[l], i, i))), method=method)
      )
    names(ent[[l]]) <- c("pos1", "pos2", "pos3")
  }
  names(ent) <- names(x)
 return(ent)
}


# Get mixed clusters -----------------------------------------------------

#' Get mixed clusters
#'
#' @description Cluster sequences at a certain taxonomic similarity, and find clusters that contain mixed taxonomic names,
#' @description Note, it is recommended to set a unique seed using set.seed()
#' @param x	 A DNAbin list object whose names include NCBItaxonomic identification numbers.
#' @param db A taxonomic database from `get_ncbi_lineage` or `get_ott_lineage`
#' @param rank The taxonomic rank to check clusters at, accepts a character such as "order", or vector of characters such as c("species", "genus").
#' If "all", the clusters will be checked at all taxonomic ranks available.
#' @param threshold numeric between 0 and 1 giving the OTU identity cutoff for clustering. Defaults to 0.97.
#' @param rngseed	(Optional). A single integer value passed to set.seed, which is used to fix a seed for reproducibly random number generation for the kmeans clustering.
#' If set to FALSE, then no fiddling with the RNG seed is performed, and it is up to the user to appropriately call set.seed beforehand to achieve reproducible results.
#' @param confidence The minimum confidence value for a mixed cluster to be flagged. For example, if confidence = 0.8 (the default value)
#'  a cluster will only be flagged if the taxonomy of a sequence within the cluster differs from at least four other independent sequences in its cluster.
#'  @param nstart how many random sets should be chosen for `kmeans`, It is recommended to set the value of nstart to at least 20.
#'  While this can increase computation time, it can improve clustering accuracy considerably.
#' @param return What type of data about the data should be returned. Options include:
#' Consensus - The consensus taxonomy for each cluster and associated confidence level
#' All - Return all taxa in mixed clusters and their sequence accession numbers
#' Count - Return counts of all taxa within each cluster
#' @param quiet logical indicating whether progress should be printed to the console.
#' @param ... further arguments to pass to kmer::otu.
#'
#' @return
#' @export
#' @import tibble
#' @import dplyr
#' @import kmer
#' @import tibble
#'
#' @examples
#' \dontrun{
#' seqs <- insect::readFASTA("test.fa.gz")
#'
#' # NCBI taxonomy
#' mixed <- get_mixed_clusters(seqs, db, rank="species", threshold=0.99, confidence=0.8, quiet=FALSE)
#'
#' # OTT taxonomy
#' seqs <- map_to_ott(seqs, dir="ott3.2", from="ncbi", resolve_synonyms=TRUE, filter_bads=TRUE, remove_na = TRUE, quiet=FALSE)
#' mixed <- get_mixed_clusters(seqs, db, rank="species", threshold=0.99, confidence=0.6, quiet=FALSE)
#' }
get_mixed_clusters <- function (x, db, rank = "order", threshold = 0.97, rngseed = FALSE, confidence = 0.8, return = "consensus", nstart=20, quiet = FALSE, ...) {
  if(missing(x)) {stop("Error: x is required")}

  #Check inputs
  if(!is.numeric(threshold) | !dplyr::between(threshold, 0,1)) { stop("Threshold must be a numeric between 0 and 1")}
  if(!is.numeric(confidence) | !dplyr::between(confidence, 0,1)) { stop("Confidence must be a numeric between 0 and 1")}
  rank <- tolower(rank)
  return <- tolower(return)
  if(!return %in% c("consensus", "all", "counts")){stop("Return must be one of: 'consensus', 'all', or 'counts'")}
  if (as(rngseed, "logical")) {
    set.seed(rngseed)
    if (!quiet) {
      message("`set.seed(", rngseed, ")` was used to initialize repeatable random subsampling.")
      message("Please record this for your records so others can reproduce.")
      message("Try `set.seed(", rngseed, "); .Random.seed` for the full vector",
              sep = "")
      message("...")
    }
  }
  else if (!quiet) {
    message("You set `rngseed` to FALSE. Make sure you've set & recorded\n",
            " the random seed of your session for reproducibility.\n",
            "See `?set.seed`\n")
    message("...")
  }
  #Get lineage
  if(attr(db, "type")  == "ncbi"){
    source <- "ncbi"
    lineage <- taxreturn::get_lineage(x = x, db = db)
  } else if(attr(db, "type")  == "OTT"){
    source <- "OTT"
    lineage <- taxreturn::get_ott_lineage(x = x, db = db)
  } else (stop("db type is not supported"))

  # Cluster OTUS
  if (is.null(attr(x, "OTU"))) {
    if (!quiet) {cat(paste0("Clustering OTUs at ", (threshold*100), "%  similarity \n"))}
    otus <- kmer::otu(x, nstart = 20, threshold = threshold, ...)
  } else {
    if (!quiet) {cat("Obtaining OTU membership from input object\n")}
    otus <- attr(x, "OTU")
    stopifnot(length(x) == length(otus))
  }
  if(length(unique(otus))==1) {
    warning("Only one unique cluster")
    return(NULL)
  }
  if (!quiet) {cat("Comparing lineage metadata within OTUs\n")}

  # Get mixed clusters
  find_mixed <- function(y, return) {
    # Ensure no duplicated accessions+names to bias confidence
    hashes <- paste0(gsub("\\|.*$", "\\1", names(y)), y)
    yu <- y[!duplicated(hashes)]
    if (length(unique(yu)) < 2) {
      return(NULL)
    }
    # Tabulate taxon names
    tab <- sort(table(yu), decreasing = TRUE)

    if(return == "consensus"){
      consensus <- names(tab)[1]
      consensus_taxid <- gsub("^.*\\|", "\\1", names(y)[y==consensus][1])
      mixed <- y != consensus #potential misannotated
      mixedu <- yu != consensus
      nu <- length(mixedu)

      #Check if there is a clear consensus
      if (tab[1] == tab[2]){
        consensus <- NA
        consensus_taxid <- NA
      }
      res <- data.frame(listed = y[mixed],
                        consensus = rep(consensus, sum(mixed)),
                        consensus_taxid = rep(consensus_taxid,sum(mixed)),
                        confidence = sum(!mixedu)/nu, cluster_size = nu,
                        stringsAsFactors = FALSE)  %>%
        tibble::rownames_to_column("Acc")
    } else if (return=="counts"){
      res <- data.frame(tax_name = names(tab),
                        count =as.numeric(tab), stringsAsFactors = FALSE)
    } else if (return=="all"){
      res <- data.frame(acc =  gsub("\\|.*$", "\\1", names(y)),
                        tax_id = gsub("^.*\\|", "\\1", names(y)),
                        tax_name = as.character(y), stringsAsFactors = FALSE)
    }

    return(res)
  }

  # Loop over rank
  results <- vector("list", length=length(rank))
  for (i in 1:length(rank)){
    lins <- lineage %>%
      dplyr::select(!!rank[i]) %>%
      dplyr::pull(!!rank[i])
    lins[is.na(lins)] <- ""
    names(lins) <- lineage$Acc
    f <- as.factor(otus)
    splitlist <- split(lins, f)
    splitlist <- splitlist[tabulate(f) > 2]

    mixedtab <- lapply(splitlist, find_mixed, return)
    mixedtab <- mixedtab[!vapply(mixedtab, is.null, logical(1))]
    if (length(mixedtab) == 0) {
      if (!quiet) {cat("No mixed clusters at", rank[i],   "rank \n")}
      results[[i]] <-  as.data.frame(NULL)
    } else if (length(mixedtab) > 0){

      mixedtab <- dplyr::bind_rows(mixedtab, .id="cluster")
      if(return == "consensus"){
        mixedtab <- mixedtab[mixedtab$confidence >= confidence, ]
      }
      if (nrow(mixedtab) == 0) {
        if (!quiet) {cat("No mixed clusters at", rank[i],   "rank \n")}
        results[[i]] <-  as.data.frame(NULL)
      } else if(nrow(mixedtab) > 0 ) {
        if(return == "consensus"){
          mixedtab <- mixedtab[order(mixedtab$confidence, decreasing = TRUE), ]
        }
        if (!quiet) {cat("identified", length(unique(mixedtab$cluster)), "mixed clusters at", rank[i],   "rank \n")}
        results[[i]] <-  mixedtab %>%
          dplyr::mutate(rank = rank[i],
                        threshold = threshold) %>%
          dplyr::mutate_if(is.factor, as.character)
      }

    }
  }

  out <- dplyr::bind_rows(results)
  if (nrow(out)==0) {
    return(NULL)
  } else (return(out))
}

